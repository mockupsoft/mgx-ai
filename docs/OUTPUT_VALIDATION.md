# Output Validation Guardrails (Phase 8.1)

**Production-stable validation for generated code output**

## Overview

The Output Validation Guardrails system ensures that code generated by the MGX Agent meets quality standards, follows stack conventions, and complies with user constraints. This validation layer acts as a safety net to catch common mistakes before they reach production.

### Key Features

âœ… **Stack-Specific Validation**: Enforces file layout requirements for each supported stack (Express TS, FastAPI, Laravel, Next.js, Vue+Vite, etc.)

âœ… **Forbidden Library Detection**: Prevents mixing incompatible technologies (e.g., Django imports in FastAPI code)

âœ… **FILE Manifest Compliance**: Validates strict format requirements for file-based output

âœ… **Path Security**: Blocks path traversal attacks and dangerous file system access

âœ… **Constraint Enforcement**: Validates user-provided constraints like "no extra libraries"

âœ… **Auto-Revision**: Automatically retries generation with error feedback when validation fails

## Validation Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  WriteCode Action                                            â”‚
â”‚                                                              â”‚
â”‚  1. Generate code output                                    â”‚
â”‚  2. Run validate_output_constraints()                       â”‚
â”‚  3. Validation passed? âœ… â†’ Return output                   â”‚
â”‚     Validation failed? âŒ â†’ Build revision prompt           â”‚
â”‚  4. Retry with validation errors (max 2 retries)           â”‚
â”‚  5. Still fails? â†’ Mark as NEEDS_INFO                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Validation Rules by Stack

### Express TypeScript (`express-ts`)

**Required Files:**
- `package.json` - Node.js dependencies
- `tsconfig.json` - TypeScript configuration
- `src/` directory - Source code

**Required Commands:**
- `npm run dev`
- `npm run build`
- `npm test`

**Forbidden Files:**
- `requirements.txt` (Python)
- `composer.json` (PHP)
- `pyproject.toml` (Python)
- `Gemfile` (Ruby)

**Forbidden Imports:**
- `from django` (Python framework)
- `from flask` (Python framework)
- `import laravel` (PHP framework)
- `require('laravel')` (PHP framework)

**Example Valid Output:**
```
FILE: package.json
{
  "name": "my-api",
  "dependencies": {
    "express": "^4.18.0",
    "dotenv": "^16.0.0"
  },
  "scripts": {
    "dev": "ts-node src/index.ts",
    "build": "tsc",
    "test": "jest"
  }
}

FILE: tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "./dist"
  }
}

FILE: src/index.ts
import express from 'express';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
app.use(express.json());

app.get('/', (req, res) => {
  res.json({ message: 'Hello World' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

---

### FastAPI (`fastapi`)

**Required Files:**
- `main.py` - Main application entry
- `requirements.txt` OR `pyproject.toml` - Python dependencies
- `app/` directory - Application code

**Required Commands:**
- `uvicorn` (for running)
- `pytest` (for testing)

**Forbidden Files:**
- `composer.json` (PHP)
- `Gemfile` (Ruby)

**Forbidden Imports:**
- `import express` (Node.js)
- `require(` (Node.js)
- `use Illuminate` (Laravel/PHP)
- `from django` (Different Python framework)

**Example Valid Output:**
```
FILE: main.py
from fastapi import FastAPI
from app.routers import users

app = FastAPI(title="My API")

app.include_router(users.router)

@app.get("/")
def read_root():
    return {"message": "Welcome to My API"}

FILE: requirements.txt
fastapi==0.104.0
uvicorn[standard]==0.24.0
pydantic==2.4.0
python-dotenv==1.0.0

FILE: app/__init__.py

FILE: app/routers/users.py
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel

router = APIRouter(prefix="/users", tags=["users"])

class User(BaseModel):
    id: int
    name: str
    email: str

@router.get("/{user_id}")
def get_user(user_id: int):
    return User(id=user_id, name="John Doe", email="john@example.com")
```

---

### Laravel (`laravel`)

**Required Files:**
- `composer.json` - PHP dependencies
- `.env.example` - Environment variables template
- `app/` directory - Application logic
- `routes/` directory - Route definitions

**Required Commands:**
- `php artisan serve`
- `php artisan test`
- `composer test`

**Forbidden Files:**
- `requirements.txt` (Python)
- `pyproject.toml` (Python)
- `Gemfile` (Ruby)

**Forbidden Imports:**
- `import express` (Node.js)
- `from fastapi` (Python)
- `from django` (Python)
- `import React` (Frontend)

**Example Valid Output:**
```
FILE: composer.json
{
    "name": "my-app",
    "require": {
        "php": "^8.1",
        "laravel/framework": "^10.0"
    }
}

FILE: .env.example
APP_NAME=MyApp
APP_ENV=local
APP_KEY=
DB_CONNECTION=mysql

FILE: routes/web.php
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\UserController;

Route::get('/', function () {
    return view('welcome');
});

Route::resource('users', UserController::class);

FILE: app/Http/Controllers/UserController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class UserController extends Controller
{
    public function index()
    {
        return response()->json(['message' => 'Users list']);
    }
}
```

---

### Next.js (`nextjs`)

**Required Files:**
- `package.json` - Node.js dependencies
- `next.config.js` - Next.js configuration
- `tsconfig.json` - TypeScript configuration
- `app/` OR `pages/` directory - Routes

**Required Commands:**
- `npm run dev`
- `npm run build`

**Forbidden Files:**
- `vite.config` (Different bundler)
- `requirements.txt` (Python)
- `composer.json` (PHP)

**Forbidden Imports:**
- `from 'react-router'` (Next.js has built-in routing)
- `createBrowserRouter` (Use Next.js routing)
- `from 'vite'` (Different bundler)

---

### Vue + Vite (`vue-vite`)

**Required Files:**
- `package.json` - Node.js dependencies
- `vite.config.ts` - Vite configuration
- `src/` directory - Source code

**Required Commands:**
- `npm run dev`
- `npm run build`

**Forbidden Files:**
- `next.config` (Next.js specific)
- `nuxt.config` (Nuxt.js specific)
- `requirements.txt` (Python)

**Forbidden Imports:**
- `from 'next'` (Different framework)
- `import React` (Different framework)
- `from 'react'` (Different framework)

---

## Forbidden Libraries Scanner

### How It Works

The scanner detects forbidden import/require statements using regex patterns. It's **context-aware** and ignores:

- Comments (lines starting with `#`, `//`, `/*`)
- String literals (inside quotes)

### Examples

**âŒ FAIL - Express import in FastAPI:**
```python
from fastapi import FastAPI
import express  # âŒ Forbidden in Python

app = FastAPI()
```
**Error:** `Forbidden import/usage in stack 'fastapi': 'import express'`

---

**âœ… PASS - Comment is OK:**
```python
from fastapi import FastAPI
# We could use express but we're using FastAPI
# import express would be wrong

app = FastAPI()
```

---

**âŒ FAIL - Django in FastAPI:**
```python
from fastapi import FastAPI
from django.http import HttpResponse  # âŒ Wrong framework

app = FastAPI()
```
**Error:** `Forbidden import/usage in stack 'fastapi': 'from django'`

---

## Constraint Enforcement

### User Constraint: "No Extra Libraries"

When a user specifies the constraint `"no extra libraries"`, the validator checks that only **common dependencies** and **built-in modules** are used.

**FastAPI Common Dependencies:**
- `fastapi`, `uvicorn`, `pydantic`, `python-dotenv`

**Python Built-ins (Always Allowed):**
- `os`, `sys`, `json`, `re`, `typing`, `dataclasses`, `datetime`, `pathlib`

**Example - FAIL:**
```python
from fastapi import FastAPI
import requests  # âŒ Not in common deps
import numpy as np  # âŒ Not in common deps

app = FastAPI()
```
**Error:** `Constraint 'no extra libraries': Found import 'requests' which is not in common dependencies`

**Example - PASS:**
```python
from fastapi import FastAPI
from pydantic import BaseModel
import os
import json

app = FastAPI()
```

---

## FILE Manifest Compliance

### Strict Mode vs Normal Mode

#### Strict Mode (`strict_mode=True`)

**Requirements:**
- Every line must be inside a FILE block or empty
- No prose/explanations outside FILE blocks
- FILE: prefix must be exact
- No duplicate file definitions

**Example - FAIL:**
```
Here's my solution:  âŒ Prose outside FILE block

FILE: main.py
def hello():
    pass

This is great!  âŒ Prose outside FILE block
```

**Example - PASS:**
```
FILE: main.py
def hello():
    pass

FILE: tests/test_main.py
def test_hello():
    assert hello() is not None
```

#### Normal Mode (`strict_mode=False`)

**Allows:**
- Explanations before/after FILE blocks
- Traditional code blocks (```python)
- More lenient parsing

**Example - PASS:**
```
Here's my FastAPI implementation:

FILE: main.py
from fastapi import FastAPI
app = FastAPI()

Or you can use:

```python
def alternative():
    pass
```

This implements the requested feature.
```

---

## Path Security Validation

### Path Traversal Prevention

**âŒ FAIL - Path Traversal:**
```
FILE: ../../../etc/passwd
FILE: ../../config/secrets.yml
```
**Error:** `Path traversal detected: ../../../etc/passwd`

**âŒ FAIL - Dangerous Absolute Paths:**
```
FILE: /etc/shadow
FILE: /var/log/auth.log
```
**Error:** `Dangerous absolute path: /etc/shadow`

**âœ… PASS - Safe Relative Paths:**
```
FILE: src/main.py
FILE: tests/test_main.py
FILE: config/settings.json
```

---

## Duplicate File Detection

**âŒ FAIL:**
```
FILE: main.py
def hello():
    pass

FILE: routes.py
def route():
    pass

FILE: main.py  âŒ Duplicate!
def goodbye():
    pass
```
**Error:** `Duplicate file definition: main.py (defined 2 times)`

---

## Mixed Stack Detection

The validator warns when multiple stack indicators are present (e.g., both `package.json` and `requirements.txt`).

**âš ï¸ WARNING:**
```
FILE: package.json
{
  "name": "mixed"
}

FILE: requirements.txt
fastapi==0.104.0

FILE: src/index.ts
import express from 'express';

FILE: main.py
from fastapi import FastAPI
```
**Warning:** `Mixed stack detected: Expected 'nodejs' (based on express-ts) but also found indicators for: python. This might be intentional (monorepo) or a mistake.`

---

## Auto-Revision on Validation Failure

When validation fails, WriteCode automatically:

1. Logs detailed validation errors
2. Builds a revision prompt with all errors
3. Retries generation (max 2 retries)
4. Returns output with NEEDS_INFO status if still fails

### Example Revision Prompt

```
âš ï¸ OUTPUT VALIDATION FAILED

The previous output did not pass validation checks. Please fix the following issues:

ERRORS (MUST FIX):
- Stack 'express-ts' requires file: package.json
- Stack 'express-ts' requires file: tsconfig.json
- Forbidden import/usage in stack 'express-ts': 'from django'

WARNINGS (RECOMMENDED TO FIX):
- Stack 'express-ts' typically uses command: npm run dev (not found in output)

Original Task: Create an Express TypeScript REST API with user authentication

Please regenerate the output addressing ALL validation errors above.
Ensure:
1. All required files for the stack are present
2. No forbidden libraries or files are used
3. FILE manifest format is correct (if required)
4. All file paths are valid and secure
5. No duplicate file definitions

Generate the complete, corrected output now.
```

---

## How to Extend Validation for New Stacks

### 1. Add Stack Specification

In `mgx_agent/stack_specs.py`:
```python
STACK_SPECS["my-new-stack"] = StackSpec(
    stack_id="my-new-stack",
    name="My New Framework",
    category=StackCategory.BACKEND,
    language="go",
    test_framework="go test",
    package_manager="go mod",
    # ... other fields
)
```

### 2. Add Validation Rules

In `mgx_agent/guardrails.py`:
```python
STACK_VALIDATION_RULES["my-new-stack"] = {
    "required_files": ["go.mod", "main.go"],
    "required_dirs": ["cmd/", "pkg/"],
    "forbidden_files": ["package.json", "requirements.txt"],
    "required_commands": ["go run", "go test", "go build"],
    "forbidden_imports": [
        r"import\s+express",
        r"from\s+fastapi",
    ],
}
```

### 3. Add Tests

In `tests/unit/test_output_validation.py`:
```python
def test_my_new_stack_required_files():
    files = ["README.md"]
    errors = StackValidator.validate_required_files(files, "my-new-stack")
    assert len(errors) >= 1
    assert any("go.mod" in e for e in errors)
```

---

## Troubleshooting

### "Why did my code fail validation?"

#### Error: "No FILE: blocks found in strict mode"

**Cause:** Strict mode requires FILE manifest format.

**Fix:** Use FILE: prefix for each file:
```
FILE: main.py
<content>

FILE: tests/test_main.py
<content>
```

---

#### Error: "Stack 'express-ts' requires file: package.json"

**Cause:** Required file is missing for the selected stack.

**Fix:** Add the required file:
```
FILE: package.json
{
  "name": "my-app",
  "dependencies": {
    "express": "^4.18.0"
  }
}
```

---

#### Error: "Forbidden import/usage in stack 'fastapi': 'import express'"

**Cause:** Mixing incompatible technologies.

**Fix:** Remove the forbidden import and use the correct stack's libraries:
```python
# âŒ Wrong
from fastapi import FastAPI
import express

# âœ… Correct
from fastapi import FastAPI
```

---

#### Error: "Path traversal detected: ../../../etc/passwd"

**Cause:** Dangerous file path.

**Fix:** Use safe relative paths within project:
```
# âŒ Wrong
FILE: ../../../etc/passwd

# âœ… Correct
FILE: config/settings.json
```

---

#### Error: "Duplicate file definition: main.py"

**Cause:** Same file defined multiple times.

**Fix:** Merge duplicate files or remove duplicates.

---

#### Warning: "Mixed stack detected"

**Cause:** Multiple stack indicators found (e.g., both package.json and requirements.txt).

**Context:** This might be intentional (monorepo) or a mistake.

**Action:** If intentional, ignore warning. If mistake, remove files from the wrong stack.

---

## Configuration

### Disable Validation (Not Recommended)

```python
from mgx_agent.actions import WriteCode

action = WriteCode()
output = await action.run(
    instruction="Create an API",
    enable_validation=False  # Disable validation
)
```

### Adjust Max Retries

```python
output = await action.run(
    instruction="Create an API",
    max_validation_retries=3  # Default is 2
)
```

### Use Strict Mode

```python
output = await action.run(
    instruction="Create an API",
    strict_mode=True  # Enforce FILE-only format
)
```

---

## Best Practices

1. **Always Enable Validation in Production**: Catches mistakes early
2. **Use Strict Mode for Multi-File Projects**: Ensures clean FILE manifest format
3. **Provide Clear Constraints**: Be specific about requirements (e.g., "no extra libraries")
4. **Review Warnings**: Even if validation passes, warnings may indicate issues
5. **Test New Stacks Thoroughly**: Add comprehensive validation rules when adding new stacks

---

## API Reference

### `validate_output_constraints()`

```python
def validate_output_constraints(
    generated_output: str,
    stack_spec: Optional[StackSpec] = None,
    constraints: Optional[List[str]] = None,
    strict_mode: bool = False,
) -> ValidationResult:
    """
    Validate generated output against stack specifications and constraints.
    
    Args:
        generated_output: Complete FILE manifest or code output
        stack_spec: Stack specification (from Phase 7)
        constraints: User-provided constraints (e.g., ["no extra libraries"])
        strict_mode: If True, enforce FILE-only format, no prose allowed
    
    Returns:
        ValidationResult with is_valid, errors, and warnings
    """
```

### `ValidationResult`

```python
class ValidationResult(BaseModel):
    is_valid: bool  # Whether output passed all validations
    errors: List[str]  # Critical errors (must fix)
    warnings: List[str]  # Non-critical warnings
    
    def add_error(self, error: str)
    def add_warning(self, warning: str)
    def summary(self) -> str  # Human-readable summary
```

### `build_revision_prompt()`

```python
def build_revision_prompt(
    validation_result: ValidationResult,
    original_task: str
) -> str:
    """
    Build a revision prompt based on validation errors.
    
    Returns:
        Revision prompt string for LLM
    """
```

---

## Summary

The Output Validation Guardrails system provides:

- âœ… **Quality Assurance**: Catches common mistakes automatically
- âœ… **Stack Compliance**: Ensures generated code follows conventions
- âœ… **Security**: Prevents dangerous file system operations
- âœ… **Auto-Correction**: Retries with feedback when validation fails
- âœ… **Extensibility**: Easy to add validation for new stacks
- âœ… **Clear Feedback**: Detailed error messages help users understand issues

**Result:** Production-stable code generation with confidence! ðŸš€
