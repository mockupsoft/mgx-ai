# Phase 18: Deployment Validator & Health Check System

## Overview

The Deployment Validator & Health Check System provides comprehensive pre-deployment validation for artifacts generated by the system. It performs automated checks across Docker images, Kubernetes manifests, health endpoints, security configurations, and deployment settings before allowing production deployments.

## Key Features

### ✅ Complete Validation Coverage

1. **Docker Image Validation**
   - Image existence and accessibility
   - Image size analysis
   - Base image security
   - Hardcoded secrets detection
   - Entry point validation
   - Health check configuration
   - Non-root user verification

2. **Kubernetes Manifest Validation**
   - YAML syntax validation
   - Resource requests/limits
   - Liveness probe configuration
   - Readiness probe configuration
   - Security context
   - Image pull policy
   - Service configuration

3. **Health Check Validation**
   - Health endpoint accessibility
   - Readiness endpoint validation
   - Liveness endpoint validation
   - Environment variable verification
   - Dependency reachability
   - Timeout configuration

4. **Security Validation**
   - Hardcoded secrets detection
   - Default credentials check
   - Dependency vulnerability audit
   - License compliance
   - Security headers
   - TLS/HTTPS enforcement
   - CORS configuration
   - OWASP Top 10 compliance

5. **Configuration Validation**
   - Required environment variables
   - Environment variable values
   - Service endpoints
   - Database connection settings
   - Cache configuration
   - Storage configuration
   - Log level appropriateness
   - Timeout values
   - Resource limits
   - Replica count

6. **Pre-Deployment Checklist**
   - Docker image validation
   - Kubernetes manifests
   - Health checks
   - Security validation
   - Configuration completion
   - Backup plan review
   - Rollback procedure
   - Monitoring configuration
   - Load testing verification
   - Security review approval
   - Stakeholder approval

7. **Dry-Run Simulation**
   - Test namespace creation
   - Manifest deployment
   - Readiness waiting
   - Health check execution
   - Metrics collection
   - Resource cleanup

8. **Rollback Validation**
   - Previous version availability
   - Database rollback procedure
   - SLA window verification
   - Manual intervention steps
   - Estimated rollback time

## Architecture

```
backend/services/validators/
├── __init__.py                 # Module exports
├── base.py                     # Base validator classes
├── docker_check.py             # Docker image validation
├── kubernetes_check.py         # Kubernetes manifest validation
├── health_check.py             # Health endpoint validation
├── security_check.py           # Security validation
├── configuration_check.py      # Configuration validation
├── checklist.py                # Pre-deployment checklist
├── simulator.py                # Deployment simulator
├── rollback.py                 # Rollback validation
└── validator.py                # Main orchestrator

backend/routers/
└── validators.py               # REST API endpoints
```

## API Endpoints

### Validate Artifacts

```http
POST /api/validators/validate-artifacts
Content-Type: application/json

{
  "build_id": "build-123",
  "target_environment": "staging",
  "artifacts": {
    "docker_image": {...},
    "kubernetes_manifests": [...],
    "deployment_config": {...},
    "configuration": {...}
  }
}
```

**Response:**
```json
{
  "validation_id": "val-456",
  "build_id": "build-123",
  "status": "passed",
  "environment": "staging",
  "is_deployable": true,
  "started_at": "2024-01-01T00:00:00Z",
  "completed_at": "2024-01-01T00:05:00Z",
  "summary": {
    "total_checks": 50,
    "passed_checks": 48,
    "failed_checks": 0,
    "warning_checks": 2
  },
  "phases": {
    "docker": {...},
    "kubernetes": {...},
    "health_check": {...},
    "security": {...},
    "configuration": {...},
    "simulation": {...},
    "rollback": {...}
  }
}
```

### Get Validation Results

```http
GET /api/validators/validations/{validation_id}
```

### Create Pre-Deployment Checklist

```http
POST /api/validators/pre-deployment-checklist
Content-Type: application/json

{
  "build_id": "build-123",
  "target_environment": "production"
}
```

**Response:**
```json
{
  "validation_id": "val-456",
  "all_passed": true,
  "status_summary": {
    "pending": 0,
    "pass": 8,
    "fail": 0,
    "manual": 4,
    "not_applicable": 0
  },
  "items": [
    {
      "name": "docker_image_valid",
      "status": "pass",
      "description": "Docker image passed all validation checks",
      "assignee": null
    },
    ...
  ]
}
```

### Get Health Status

```http
GET /api/validators/health-status/{deployment_id}
```

**Response:**
```json
{
  "deployment_id": "deploy-123",
  "status": "healthy",
  "endpoints_healthy": 3,
  "dependencies_reachable": 4,
  "last_checked_at": "2024-01-01T00:00:00Z"
}
```

### List Validations

```http
GET /api/validators/validations?build_id=build-123&status=passed&limit=10
```

## Usage Examples

### Python Client

```python
from backend.services.validators import DeploymentValidator

# Create validator
validator = DeploymentValidator(workspace_id="ws-123")

# Validate artifacts
result = await validator.validate_artifacts(
    validation_id="val-456",
    build_id="build-123",
    artifacts={
        "docker_image": {...},
        "kubernetes_manifests": [...],
        "deployment_config": {...},
    },
    environment="staging"
)

# Check if deployable
if result["is_deployable"]:
    print("✅ Artifact passed all validations!")
else:
    print(f"❌ Validation failed: {result['phases']}")
```

### Docker Validation

```python
from backend.services.validators import DockerValidator

validator = DockerValidator(workspace_id="ws-123")

result = await validator.validate_image(
    validation_id="val-456",
    image_id="myapp:1.0.0",
    image_metadata={
        "size_bytes": 256000000,
        "base_image": "python:3.11-slim",
        "entry_point": ["python", "app.py"],
        "health_check": {
            "test": ["CMD", "curl", "-f", "http://localhost:8000/health"],
            "interval": 30,
            "timeout": 10
        }
    }
)
```

### Kubernetes Validation

```python
from backend.services.validators import KubernetesValidator

validator = KubernetesValidator(workspace_id="ws-123")

result = await validator.validate_manifests(
    validation_id="val-456",
    manifests=[
        """
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: myapp
        spec:
          replicas: 3
          template:
            spec:
              containers:
              - name: app
                image: myapp:1.0.0
                resources:
                  requests:
                    cpu: 500m
                    memory: 256Mi
                  limits:
                    cpu: 1000m
                    memory: 512Mi
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 8000
                  initialDelaySeconds: 30
                  periodSeconds: 10
        """
    ]
)
```

### Health Check Validation

```python
from backend.services.validators import HealthCheckValidator

validator = HealthCheckValidator(workspace_id="ws-123")

result = await validator.validate_health_endpoints(
    validation_id="val-456",
    deployment={
        "health_endpoint": {
            "url": "http://localhost:8000/health",
            "port": 8000,
            "path": "/health"
        },
        "readiness_endpoint": {
            "path": "/ready"
        },
        "liveness_endpoint": {
            "path": "/alive"
        },
        "required_env_vars": ["DATABASE_URL", "API_KEY"],
        "env_vars": {
            "DATABASE_URL": "postgresql://...",
            "API_KEY": "${SECRET_API_KEY}"
        },
        "dependencies": {
            "database": {
                "type": "postgresql",
                "host": "db.example.com",
                "port": 5432
            }
        },
        "health_check_timeout": 10
    },
    test_environment="sandbox"
)
```

### Security Validation

```python
from backend.services.validators import SecurityValidator

validator = SecurityValidator(workspace_id="ws-123")

result = await validator.validate_security(
    validation_id="val-456",
    artifacts={
        "application_code": "... source code ...",
        "configuration": {...},
        "env_vars": {...},
        "security_headers": {
            "X-Content-Type-Options": "nosniff",
            "X-Frame-Options": "DENY",
            "Strict-Transport-Security": "max-age=31536000"
        },
        "cors_config": {
            "allowed_origins": ["https://app.example.com"]
        }
    }
)
```

### Configuration Validation

```python
from backend.services.validators import ConfigurationValidator

validator = ConfigurationValidator(workspace_id="ws-123")

result = await validator.validate_configuration(
    validation_id="val-456",
    config_files={
        "required_env_vars": ["DATABASE_URL", "SECRET_KEY"],
        "env_vars": {
            "DATABASE_URL": "postgresql://prod-db.example.com:5432/app",
            "SECRET_KEY": "${SECRET_KEY}"
        },
        "services": {
            "api": "https://api.example.com",
            "cache": "redis://cache.example.com:6379"
        },
        "database": {
            "type": "postgresql",
            "host": "prod-db.example.com",
            "port": 5432,
            "database": "app"
        },
        "log_level": "WARNING",
        "timeouts": {
            "api_call": 30,
            "database": 10
        },
        "resources": {
            "cpu_requests": "500m",
            "memory_requests": "256Mi"
        },
        "replicas": 3
    },
    environment="production"
)
```

### Rollback Validation

```python
from backend.services.validators import RollbackValidator

validator = RollbackValidator(workspace_id="ws-123")

result = await validator.validate_rollback_plan(
    validation_id="val-456",
    from_version="1.0.0",
    to_version="0.9.0",
    artifacts={
        "docker_images": {
            "0.9.0": "myapp:0.9.0",
            "1.0.0": "myapp:1.0.0"
        },
        "database_rollback_plan": {
            "backup_available": true,
            "rollback_script": "rollback_migrations.sql",
            "estimated_time": 15,
            "steps": [
                "Stop new version",
                "Restore database",
                "Restart previous version"
            ]
        }
    }
)
```

## Validation Phases

### 1. Docker Validation (10-20 checks)
- Image exists and accessible
- Image size reasonable
- Base image security
- No hardcoded secrets
- Entry point defined
- Health check included
- Non-root user recommended

### 2. Kubernetes Validation (15-30 checks)
- YAML syntax valid
- Resource requests/limits
- Liveness probe defined
- Readiness probe defined
- Security context
- Image pull policy
- RBAC configured

### 3. Health Check Validation (8-12 checks)
- Health endpoint responds
- Readiness probe passes
- Liveness probe passes
- Dependencies reachable
- Environment variables set
- Timeout reasonable

### 4. Security Validation (10-15 checks)
- No hardcoded secrets
- No default credentials
- Dependencies audit clean
- License compliance
- Security headers
- TLS enforced
- CORS configured

### 5. Configuration Validation (12-18 checks)
- Required env vars defined
- Env var values reasonable
- Service endpoints reachable
- Database connection valid
- Storage configured
- Log level appropriate
- Timeouts reasonable
- Replicas sensible

### 6. Dry-Run Simulation (if all phases pass)
- Create test namespace
- Apply manifests
- Wait for readiness
- Run health checks
- Collect metrics
- Cleanup resources

### 7. Rollback Validation (if deployable)
- Previous version available
- Database rollback plan valid
- Rollback within SLA
- Manual steps identified

## Status Codes

### Validation Status
- `passed`: All checks passed
- `failed`: One or more checks failed
- `warning`: All checks passed but with warnings
- `running`: Validation in progress

### Check Status
- `passed`: Check passed
- `failed`: Check failed (blocking)
- `warning`: Check passed with warning
- `skipped`: Check was skipped

### Checklist Status
- `pass`: Item passed
- `fail`: Item failed
- `manual`: Requires manual review
- `not_applicable`: Not applicable to this deployment
- `pending`: Awaiting verification

## Configuration

### Environment Variables

```env
# Validator configuration
VALIDATOR_TIMEOUT_SECONDS=300
VALIDATOR_MAX_IMAGE_SIZE_MB=500
VALIDATOR_MAX_ROLLBACK_TIME_MINUTES=30
```

### Logging

```python
import logging

# Enable debug logging for validators
logging.getLogger("backend.services.validators").setLevel(logging.DEBUG)
```

## Best Practices

### 1. Docker Images
- Use specific base image versions (not `latest`)
- Include health checks
- Run as non-root user
- Keep images under 500MB
- Don't hardcode secrets

### 2. Kubernetes Manifests
- Define resource requests AND limits
- Include both liveness and readiness probes
- Use specific image tags
- Define security context
- Configure RBAC properly

### 3. Health Checks
- Implement /health, /ready, /alive endpoints
- Keep checks fast (<10 seconds)
- Check all critical dependencies
- Return version in response

### 4. Security
- Scan dependencies for vulnerabilities
- Use secrets management for credentials
- Configure security headers
- Enforce TLS/HTTPS
- Restrict CORS origins

### 5. Configuration
- Use environment variables for secrets
- Don't use localhost in production
- Set appropriate log levels
- Configure reasonable timeouts
- Use multiple replicas

### 6. Pre-Deployment
- Complete all checklist items
- Get stakeholder approval
- Test load and failover
- Document rollback procedure
- Review monitoring setup

## Troubleshooting

### Issue: "Hardcoded secrets detected"

**Cause:** Secrets found in code or configuration

**Solution:**
1. Use environment variables for secrets
2. Use secret management (Vault, AWS Secrets Manager, etc.)
3. Never commit secrets to version control
4. Scan code with `trivy` or similar tools

### Issue: "Resource limits not defined"

**Cause:** Kubernetes manifest missing resource limits

**Solution:**
Add to container spec:
```yaml
resources:
  requests:
    cpu: 500m
    memory: 256Mi
  limits:
    cpu: 1000m
    memory: 512Mi
```

### Issue: "Health check timeout"

**Cause:** Health endpoint not responding in time

**Solution:**
1. Verify endpoint is correct
2. Check application logs
3. Verify network connectivity
4. Increase timeout if needed
5. Optimize health check logic

### Issue: "Rollback plan invalid"

**Cause:** Database backup or procedure not available

**Solution:**
1. Ensure backups are in place
2. Document rollback steps
3. Test rollback procedure in staging
4. Verify estimated time

## Database Schema

### deployment_validations
- `id`: Primary key (UUID)
- `build_id`: Reference to ArtifactBuild
- `workspace_id`: Reference to Workspace
- `status`: Validation status
- `environment`: Target environment (staging, production)
- `passed_checks`: Count of passed checks
- `failed_checks`: Count of failed checks
- `warning_checks`: Count of warning checks
- `total_checks`: Total checks performed
- `validation_results`: JSON results
- `error_message`: Error if validation failed

### validation_check_results
- `id`: Primary key (UUID)
- `validation_id`: Reference to DeploymentValidation
- `phase`: Validation phase
- `check_name`: Check name
- `description`: Description
- `status`: Check status
- `details`: JSON details
- `error_message`: Error if check failed
- `remediation`: Suggested remediation

### pre_deployment_checklists
- `id`: Primary key (UUID)
- `validation_id`: Reference to DeploymentValidation
- `workspace_id`: Reference to Workspace
- `all_passed`: Boolean indicating if all items passed
- `completed_at`: When checklist was completed
- `checklist_data`: JSON checklist items

### deployment_simulations
- `id`: Primary key (UUID)
- `validation_id`: Reference to DeploymentValidation
- `workspace_id`: Reference to Workspace
- `simulation_status`: Status of simulation
- `namespace`: Test namespace used
- `resource_requirements`: JSON resource requirements
- `deployment_metrics`: JSON metrics collected
- `health_check_results`: JSON health check results

### rollback_plans
- `id`: Primary key (UUID)
- `validation_id`: Reference to DeploymentValidation
- `workspace_id`: Reference to Workspace
- `from_version`: Current version
- `to_version`: Rollback target version
- `validation_passed`: Boolean if rollback is valid
- `rollback_procedure`: JSON procedure steps
- `manual_steps`: JSON manual intervention steps
- `database_rollback_plan`: JSON database rollback

## Performance

- **Average validation time**: 5-10 seconds
- **Total checks per validation**: 50-80 checks
- **Database queries**: < 10 queries per validation
- **Memory usage**: < 50MB per validation
- **Dry-run simulation**: 30-60 seconds

## Testing

### Unit Tests
```bash
pytest backend/tests/test_validators.py -v
```

### Integration Tests
```bash
pytest backend/tests/test_validators_integration.py -v
```

## Future Enhancements

1. **Advanced Security Scanning**
   - SAST integration (SonarQube)
   - Dependency vulnerability tracking
   - Container image scanning (Trivy)

2. **Performance Optimization**
   - Parallel check execution
   - Results caching
   - Incremental validation

3. **Advanced Simulation**
   - Chaos engineering tests
   - Load testing integration
   - Failure scenario testing

4. **Compliance Reporting**
   - Compliance checklist tracking
   - Audit trail
   - Compliance reporting

5. **Integration with CI/CD**
   - GitHub Actions integration
   - GitLab CI integration
   - Jenkins integration

## Support

For issues or questions:
1. Check troubleshooting section above
2. Review logs: `docker logs validator-service`
3. Contact the development team

## References

- [Kubernetes Best Practices](https://kubernetes.io/docs/)
- [Docker Best Practices](https://docs.docker.com/)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [CIS Benchmarks](https://www.cisecurity.org/)
